---
author: KrDw
pubDatetime: 2024-03-22T14:24:19.000+08:00
modDatetime: 2024-04-23T00:24:47.000+08:00
title: 《C Primer Plus》学习笔记
featured: false
draft: true
tags:
  - c
description: ""
---

<center><img src="https://img.k1r.in/2024/05/picgo_13b0396e180c1aaf4c548fb3d90a7e68.png" width="135px" height="200px"> </center>
<center><font size=4>《C Primer Plus（第6版）中文版》</font></center>
<center><font color='#6e6e6e' size=2>作者：普拉达(StephenPrata)</font></center>
<center><font color='#6e6e6e' size=2>译者：姜佑</font></center>
<center><font color='#6e6e6e' size=2>出版社：人民邮电出版社</font></center>
<center><font color='#6e6e6e' size=2>出版年：2016-04</font></center>
<center><font color='#6e6e6e' size=2>ISBN：9787115390592</font></center>

### 第 1 章 初识 C 语言

---

‍许多初学者经常忽略第 1 步和第 2 步（定义程序目标和设计程序），直接跳到第 3 步（编写代码）。刚开始学习时，编写的程序非常简单，完全可以在脑中构思好整个过程。即使写错了，也很容易发现。但是，随着编写的程序越来越庞大、越来越复杂，动脑不动手可不行，而且程序中隐藏的错误也越来越难找。最终，那些跳过前两个步骤的人往往浪费了更多的时间，因为他们写出的程序难看、缺乏条理、让人难以理解。要编写的程序越大越复杂，事先定义和设计程序环节的工作量就越大。

---

- 本书用等宽斜体表示占位符，可以用具体的项替换这些占位符。
- 本书用相同的字体表示计算机的输出，粗体表示用户输入。
- 本书使用 \[enter\] 显式标出 Enter 键。

---

### 第 2 章 C 语言概述

---

花括号在 C 语言中的作用类似于这些语言中的 begin 和 end。

> [!Note]
>
> Verilog、Matlab 中都需要显式指出 end。

---

```c
int num;
```

声明把特定标识符与计算机内存中的特定位置联系起来，同时也确定了储存在某位置的信息类型或数据类型。

---

给变量命名时要使用有意义的变量名或标识符。

---

C99 之前的标准要求把声明都置于块的顶部，这样规定的好处是：把声明放在一起更容易理解程序的用途。C99 允许在需要时才声明变量，这样做的好处是：在给变量赋值之前声明变量，就不会忘记给变量赋值。

> [!Note]
>
> 把变量声明置于块的顶部可以提高代码的可读性，“读者友好”；在使用前声明变量更符合实际编程中的灵活需求，“作者友好”。

---

提高程序可读性的技巧：

1. 选择有意义的函数名。
2. 写注释。
3. 在函数中用空行分隔概念上的多个部分。
4. 每条语句各占一行。

> [!Note]
>
> 变量（函数）名称尽可能直接体现用途，则不必写注释。
>
> 写注释应当适量，能从代码直接读出用途的话不必赘述。
>
> 可以用空行把声明部分和程序其他部分区分开来。

---

程序在开始处有一条注释（使用新的注释风格），给出了文件名和程序的目的。写这种程序说明很简单不费时，而且在以后浏览或打印程序时很有帮助。

---

### 第 3 章 数据和 C

---

因为 C 语言只规定了 short 占用的存储空间不能多于 int, long 占用的存储空间不能少于 int。这样规定是为了适应不同的机器。

```c
//* typesize.c -- 打印类型大小 *//
#include <stdio.h>
int main(void)
{
    // c99为类型大小提供%zd转换说明
    printf("Type int has a size of %zd bytes.\n", sizeof(int));
    printf("Type char has a size of %zd bytes.\n", sizeof(char));
    printf("Type long has a size of %zd bytes.\n", sizeof(long));
    printf("Type long long has a size of %zd bytes.\n", sizeof(long long));
    printf("Type double has a size of %zd bytes.\n", sizeof(double));
    printf("Type long double has a size of %zd bytes.\n", sizeof(long double));
    return 0;
}
```

> [!Note]
>
> 64 位 Windows 系统下使用 `sizeof()` 函数查看数据类型大小。
>
> |    Type     | Bytes | Bits |
> | :---------: | :---: | :--: |
> |    char     |   1   |  8   |
> |     int     |   4   |  32  |
> |    long     |   4   |  32  |
> |  long long  |   8   |  64  |
> |   double    |   8   |  64  |
> | long double |  16   | 128  |

---

> [!Note]
>
> 编译器在处理短字节变量时会自动将其扩展为长字节变量以适应上下文，但当尝试将长字节变量赋值给短字节变量时，可能会发生数据截断的错误。

---

在 C 语言中，用单引号括起来的单个字符被称为字符常量（Character Constant）。编译器一发现 `'A'`，就会将其转换成相应的代码值。**单引号必不可少**。

> [!Note]
>
> 如果省略单引号，则会被当成变量名；
>
> 如果使用双引号，则会被当成字符串。

---

转义字符 `\b` `\f` `\n` `\r` `\t` 和 `\v` 是常用的输出设备控制符。了解它们最好的方式是查看它们对活跃位置的影响。

- 换页符 `\f` 把活跃位置移至下一页的开始处；
- 换行符 `\n` 把活跃位置移至下一行的开始处；
- 回车符 `\r` 把活跃位置移至当前行的开始处；
- 水平制表符 `\r` 把活跃位置移至下一个水平制表点（通常是第 1 个、第 9 个、第 17 个、第 25 个等字符位置）；
- 垂直制表符 `\v` 把活跃位置移至下一个垂直制表点。

---

使用 ASCII 码时，注意数字和数字字符的区别。例如，字符 4 对应的 ASCII 码是 52。'4' 表示字符 4，而不是数值 4。

---

默认情况下，编译器假定浮点型常量是 double 类型的精度。

---

许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。例如，用 i\_ 前缀表示 int 类型，us\_ 前缀表示 unsigned short 类型。这样一眼就能看出来 i_smart 是 int 类型的变量， us_versmart 是 unsigned short 类型的变量。

---

C 语言用逗号分隔函数中的参数。printf() 和 scanf() 函数与一般函数不同，它们的参数个数是可变的。

程序要知道函数的参数个数才能正常工作。**printf() 和 scanf() 函数用第 1 个参数表明后续有多少个参数，即第 1 个字符串中的转换说明与后面的参数一一对应**。

程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配。现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确。但是，该机制对 printf() 和 scanf() 不起作用，因为这两个函数的参数个数可变。

---

```c
int main(void){
    float salary;

    printf(" $_______\b\b\b\b\b\b\b");
    scanf("%f", &salary)
    return 0
}
```

通常，退格不会擦除退回所经过的字符，但有些实现是擦除的。

> [!Note]
>
> 使用退格 `\b` 可以实现填空。

---

### 第 4 章 字符串和格式化输入/输出

---

C 语言中没有专门用于储存字符串的变量类型，字符串都被储存在 char 类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符。

C 语言用空字符（null character）`\0` 标记字符串的结束。空字符不是数字 0，它是非打印字符，其 ASCII 码值是 0。**C 中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多 1**。

---

预处理器也可以用来定义常量。只需在程序顶部添加下面一行：

```c
#define NAME value
```

编译程序时，程序中所有的 _NAME_ 都会被替换成相应的 _value_。这一过程被称为编译时替换（compile-time substitution）。在运行程序时，程序中所有的替换均已完成。

注意，常量名与常量值之间不用加 `=` 符号；末尾不用加分号，因为这是一种由预处理器处理的替换机制。

---

用大写符号表示常量是 C 语言一贯的传统。

---

转换说明（占位符）把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。

转换（conversion）可能误导读者认为原始值被转替换成替换后的值。实际上，转换说明是翻译说明，%d 的意思是“把给定的值翻译成十进制整数文本并打印出来”。

---

在我们的系统中，short int 是 2 字节，char 是 1 字节。当 printf() 用 %c 打印 336 时，它只会查看储存在 336 的 2 字节中的后 1 字节。

**这种截断相当于用一个整数除以 256，只保留其余数**。在这种情况下，余数是 80，对应的 ASCII 值是字符 P。

用专业术语来说，该数字被解释成“以256为模”（modulo 256），即该数字除以256后取其余数。

> [!Note]
>
> 用二进制理解就是截断，用十进制理解就是取余数。

---

函数调用如下：

```c
float n1; /* 作为double类型传递 */
double n2;
long n3, n4;
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
```

该调用告诉计算机把变量 n1、n2、n3 和 n4 的值传递给程序。这是一种常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。**计算机根据变量类型（不是根据转换说明）把这些值放入栈中**。

然后，控制转到 printf() 函数。**该函数根据转换说明（不是根据变量类型）从栈中读取值**。

![参数传递入栈](https://img.k1r.in/2024/05/picgo_09e71a0384b396c98b8b9f95f4b2f3fd.png)

---

**printf() 函数也有一个返回值，它返回打印字符的个数**。如果有输出错误，printf() 则返回一个负值（printf() 的旧版本会返回不同的值）。

---

给字符串断行有 3 种方法：

1. **使用多个 printf() 语句**。因为第 1 个字符串没有以 \n 字符结束，所以第 2 个字符串紧跟第 1 个字符串末尾输出。

   ```c
   printf("Here's one way to print a ");
   printf("long string.\n");
   ```

2. **用反斜杠 \\ 和 \[Enter\] 键组合来断行**。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。

   ```c
   printf("Here's another way to print a \
   long string.\n");
   ```

3. **ANSI C 引入的字符串连接**。在两个用双引号括起来的字符串之间用空白隔开，C 编译器会把多个字符串看作是一个字符串。

   ```c
   printf("Here's the newest way to print a ""long string.\n");
   ```

---

- 如果用 scanf() 读取基本变量类型的值，在变量名前加上一个 &；
- 如果用 scanf() 把字符串读入字符数组中，不要使用 &。

---

把 \* 放在 % 和转换字符之间时，会使得 scanf() 跳过相应的输出项。

```c
scanf("%*d %*d %d", &n);
~~~
2013 2014 2015
~~~
// n = 2015
```

在程序需要读取文件中特定列的内容时，这项跳过功能很有用。

> [!Note]
>
> 类似于正则表达式中的非捕获组。

---

在程序中，最好用 \#define 定义数值常量，用 const 关键字声明的变量为只读变量。**在程序中使用明示常量，提高了程序的可读性和可维护性。**

---

### 第 5 章 运算符、表达式和语句

---

```c
cheeta = tarzan = jane = 68;
```

许多其他语言都会回避该程序中的**三重赋值**，但是 C 完全没问题。

---

另一种舍入方法是直接丢弃小数部分。这种方法被称为“**趋零截断**”，即把 -3.8 转换成 -3。在 C99 以前，不同的实现采用不同的方法。但是 C99 规定使用趋零截断。所以，应把 -3.8 转换成 -3。

---

> [!Note]
>
> ```c
> min = sec / SEC_PER_MIN; // 截断分钟数
> left = sec % SEC_PER_MIN; // 剩下的秒数
> ```
>
> sec = min + left
>
> ~~一个数等于整除得到的趋零截断值加上求模得到的余数。~~
>
> ⬇️当涉及负数整除和求模时就不对。

---

负数求模如何进行？C99 规定“趋零截断”之前，该问题的处理方法很多。但自从有了这条规则之后，

- 如果第 1 个运算对象是负数，那么求模的结果为负数；
- 如果第 1 个运算对象是正数，那么求模的结果为正数。

> [!Note]
>
> 简单来说，就是**求模运算会保留被除数的符号**。这个规律使得在进行求模运算时更加一致和可预测。

---

**序列点（sequence point）是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生**。在 C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。另外，任何一个完整表达式的结束也是一个序列点。

> [!Note]
>
> 从C语言的角度看，主要目的是对表达式求值，而赋值表达式的赋值则为所谓的“副作用”。

---

注意循环体中的缩进。**缩进对编译器不起作用，编译器通过花括号和 while 循环的结构来识别和解释指令**。这里，缩进是为了让读者一眼就可以看出程序是如何组织的。

> [!Note]
>
> 编写程序时使用缩进是为了**提高可读性**。

---

**自动类型转换**

- 当类型转换出现在表达式时，无论是 unsigned 还是 signed 的 char 和 short 都会被自动转换成 int。

- 由于都是从较小类型转换为较大类型，所以这些转换被称为升级（promotion）。

- 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。

- **类型的级别**从高至低依次是

  ```
  long double > double > float > unsigned long long > long long > unsigned long > long > unsigned int > int
  ```

- **在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型**。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。

> [!Note]
>
> 这一节需要反复学习。

---

**强制类型转换运算符**

在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型名构成了强制类型转换运算符（cast operator），其通用形式是：

```c
(type)value
```

> [!Note]
>
> - 通常，应该避免自动类型转换，尤其是类型降级。
> - 一般而言，也不应该混合使用类型，但是偶尔这样做也是有用的。

---

- 声明参数就创建了被称为形式参数（formal argument或formal parameter，简称**形参**）的变量。
- 我们称函数调用传递的值为实际参数（actual argument或actual parameter），简称**实参**。

C99 规定形参使用术语 parameter，实参使用术语 argument。

---

### 第 6 章 C 控制语句：循环

---

```c
while (status == 1){
    ...
    printf("Please enter next integer (q to quit): ");
    status = scanf("%ld", &num);
}
```

第4章中介绍过，**scanf() 返回成功读取项的数量**。如果 scanf() 成功读取一个整数，就把该数存入 num 并返回 1，随后返回值将被赋给 status（注意，用户输入的值储存在 num 中，不是 status 中）。这样做同时更新了 num 和 status 的值，while 循环进入下一次迭代。

如何告诉循环何时停止？该程序利用 scanf()的双重特性避免了在循环中交互输入时的这个棘手的问题。

> [!Note]
>
> 使用 scanf() 函数的返回值可以避免需要用户确认继续输入时还要添加一行输入和判断语句。

---

虽然关系运算符也可用来比较浮点数，但是要注意：**比较浮点数时，尽量只使用 < 和 >**。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。

---

一般而言，所有的非零值都视为真，只有 0 被视为假。

> [!Note]
>
> 不管是正数还是负数都视为真。

---

```c
input_is_good = (scanf("%ld", &num) == 1);
```

从**优先级**方面考虑的话，并不需要用**圆括号**把 `scanf("%ld", &num) == 1` 括起来。但是，这样做可以提高**代码可读性**。

---

![运算符优先级](https://img.k1r.in/2024/05/picgo_1dbbf2fbc787bf7793b176845c1ec5cc.png)

> [!Note]
>
> 结合律“从右往左”的运算符怎么理解？？？

---

```c
for (initialize; test; update)
    statement
```

for 语句使用 3 个表达式控制循环过程，分别用分号隔开。

- initialize 表达式在执行 for 语句之前只执行一次；
- 然后对 test 表达式求值，如果表达式为真（或非零），执行循环一次；
- 接着对 update 表达式求值，并再次检查 test 表达式。

for 语句是一种**入口条件循环**，即在执行循环之前就决定了是否执行循环。因此，for 循环可能一次都不执行。

---

**逗号运算符并不局限于在 for 循环中使用（用于在循环头中包含更多的表达式）**，但是这是它最常用的地方。逗号运算符有两个其他性质。

首先，它保证了被它分隔的表达式从左往右求值（换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生）。

其次，整个逗号表达式的值是右侧项的值。

> [!Note]
>
> 逗号运算符用于在一个语句中执行多个表达式。

---

while 循环和 for 循环都是**入口条件循环**，即**在循环的每次迭代之前检查测试条件**，所以有可能根本不执行循环体中的内容。C 语言还有**出口条件循环**（exit-condition loop），即**在循环的每次迭代之后检查测试条件**，这保证了至少执行循环体中的内容一次。这种循环被称为 do while 循环。

---

用于识别数组元素的数字被称为**下标（subscript）、索引（indice）或偏移量（offset）**。下标必须是整数，而且要从 0 开始计数。数组的元素被依次储存在内存中相邻的位置

---

```c
printf("Enter %d golf scores:\n", SIZE);
for (index = 0; index < SIZE; index++)
	scanf("%d", &score[index]); // 读取10个分数
printf("The scores read in are as follows:\n");
for (index = 0; index < SIZE; index++)
	printf("%5d", score[index]); // 验证输入
printf("\n");
```

> [!Note]
>
> 读取用户输入后，输出到终端用于验证是否符合预期。

---

> [!Note]
>
> 尽量避免在代码主体中出现数字字面量，最好提前到文件顶部使用 `#define` 定义常量。

---
